#include "octahedral.glsl"

uniform sampler2D   SphereSampler;
uniform samplerCube RadianceCubemap;
uniform samplerCube DistanceCubemap;

uniform int   NumSamples;
uniform float LobeSize;

#if OCT_HIGH_RES
out vec3 octRadiance;
out float octDistance;
#else
out vec3 octIrradiance;
out vec2 octMeanDistance;
#endif

const int NUM_SPHERE_SAMPLERS = 4096;

vec3 pointOnUnitSphere(int i, int n)
{
	int k = NUM_SPHERE_SAMPLERS / n;
	int index = i * k;
	//vec3 point = sphereSamplers[index%NUM_SPHERE_SAMPLERS].xyz;
	int2 SampleTexCoord = int2(i/64,i%64);
	vec3 point = texelFetch(SphereSampler, ivec2(i/64,i%64),0).xyz;
	return point;
}

void main()
{
	vec3  Radiance = vec3(0.0);
	vec3  SumRadiance = vec3(0.0, 0.0, 0.0);
	float RadianceWeight = 0.0;
	float RadianceSumWeight = 0.0;

	float Distance = 0.0;
	float SumDistance = 0.0;
	float DistanceWeight = 0.0;
	float DistanceSumWeight = 0.0;

#if OCT_HIGH_RES
	vec3 Direction = octDecode(gl_FragCoord.xy / 1024 * 2.0 - 1.0);

	octRadiance = texture(RadianceCubemap, Direction, 0).xyz;
	octDistance = length(texture(DistanceCubemap, Direction, 0).xyz);
#else
	vec3 Direction = octDecode(gl_FragCoord.xy / 128 * 2.0 - 1.0);

	for (int i = 0; i < NumSamples; i++)
	{
		vec3 Offset = pointOnUnitSphere(i, NumSamples);
		vec3 SampleDirection = normalize(Direction + LobeSize * Offset);

		//Radiance
		Radiance = texture(RadianceCubemap, SampleDirection).xyz;
		RadianceWeight = max(dot(Direction, SampleDirection), 0.0);
		SumRadiance += Radiance * RadianceWeight;
		RadianceSumWeight += RadianceWeight;

		//Distance
		Distance = length(texture(DistanceCubemap, SampleDirection).xyz);
		DistanceWeight = pow(max(dot(Direction, SampleDirection), 0.0), 2.0);
		SumDistance += Distance;
		DistanceSumWeight += DistanceWeight;
	}

	octIrradiance = SumRadiance / RadianceSumWeight;
	octMeanDistance.x = SumDistance / DistanceSumWeight;
	octMeanDistance.y = pow(octMeanDistance.x, 2.0);
#endif
}