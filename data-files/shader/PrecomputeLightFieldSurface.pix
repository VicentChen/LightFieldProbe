#include "octahedral.glsl"

uniform sampler2D   SphereSampler;
uniform samplerCube RadianceCubemap;
uniform samplerCube DistanceCubemap;
uniform samplerCube NormalCubemap;

uniform int   NumSamples;
uniform float LobeSize;

#if OCT_HIGH_RES
out vec3 octRadiance;
out float octDistance;
out vec3 octNormal;
#else
out vec3  octIrradiance;
out vec2  octMeanDistance;
out float octLowResDistance;
#endif

const int NUM_SPHERE_SAMPLERS = 4096;

vec3 pointOnUnitSphere(int i, int n)
{
	int k = NUM_SPHERE_SAMPLERS / n;
	int index = i * k;
	int2 SampleTexCoord = int2(i/64,i%64);
	vec3 point = texelFetch(SphereSampler, ivec2(i/64,i%64),0).xyz;
	return point;
}

void main()
{
	vec3  Radiance = vec3(0.0);
	vec3  SumRadiance = vec3(0.0, 0.0, 0.0);
	float RadianceWeight = 0.0;
	float RadianceSumWeight = 0.0;

	float Distance = 0.0;
	float SquareDistance = 0.0;
	float SumDistance = 0.0;
	float SumSquareDistance = 0.0;
	float DistanceWeight = 0.0;
	float DistanceSumWeight = 0.0;

#if OCT_HIGH_RES
	vec3 Direction = octDecode(gl_FragCoord.xy / 1024 * 2.0 - 1.0);

	octRadiance = texture(RadianceCubemap, Direction, 0).xyz;
	octDistance = length(texture(DistanceCubemap, Direction, 0).xyz);
	octNormal = texture(NormalCubemap, Direction, 0).xyz;
#else
	vec3 Direction = octDecode(gl_FragCoord.xy / 128 * 2.0 - 1.0);

	for (int i = 0; i < NumSamples; i++)
	{
		vec3 Offset = pointOnUnitSphere(i, NumSamples);
		vec3 SampleDirection = normalize(Direction + LobeSize * Offset);

		//Radiance
		Radiance = texture(RadianceCubemap, SampleDirection).xyz;
		RadianceWeight = max(dot(Direction, SampleDirection), 0.0);
		SumRadiance += Radiance * RadianceWeight;
		RadianceSumWeight += RadianceWeight;

		//Distance
		Distance = length(texture(DistanceCubemap, SampleDirection, 0).xyz);
		SquareDistance = pow(Distance, 2.0);
		DistanceWeight = pow(max(dot(Direction, SampleDirection), 0.0), 10.0);
		SumDistance += Distance;
		SumSquareDistance += SquareDistance;
		DistanceSumWeight += DistanceWeight;
	}

	octIrradiance = SumRadiance / RadianceSumWeight;
	octMeanDistance.x = SumDistance / DistanceSumWeight;
	octMeanDistance.y = SumSquareDistance / DistanceSumWeight;
	octLowResDistance = length(texture(DistanceCubemap, Direction, 0).xyz);
#endif
}